<h1>Solid Principles</h1>
<h3>
ðŸ”¹ SOLID Principles Summary</br>
S â€” Single Responsibility Principle (SRP)</br>
A class should have only one reason to change.</br>
Each class or module should focus on a single task or functionality, making the system easier to maintain and test.</br></br>

O â€” Open/Closed Principle (OCP)</br>
Software entities should be open for extension but closed for modification.</br>
You should be able to add new functionality without altering existing code, usually achieved through interfaces or abstract classes.</br></br>

L â€” Liskov Substitution Principle (LSP)</br>
Subtypes must be substitutable for their base types.</br>
Objects of a derived class should be usable in place of objects of the base class without breaking the application.</br></br>

I â€” Interface Segregation Principle (ISP)</br>
Clients should not be forced to depend on interfaces they do not use.</br>
Split large interfaces into smaller, more specific ones so that clients only need to know about the methods that are relevant to them.</br></br>

D â€” Dependency Inversion Principle (DIP)</br>
High-level modules should not depend on low-level modules. Both should depend on abstractions.</br>
Depend on abstractions, not concrete implementations, which improves modularity and flexibility.</br>
</h3>